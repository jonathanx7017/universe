<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEWTYPE Style Parallax Particle System</title>
    
    <!-- Google Fonts: Roboto Flex (Similar to Google Sans Flex) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap" rel="stylesheet">

    <style>
        :root {
            --font-main: 'Roboto Flex', 'Google Sans', sans-serif;
            --color-bg: #050505;
            --color-text: #ffffff;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body { 
            margin: 0; 
            background: var(--color-bg); 
            font-family: var(--font-main);
            color: var(--color-text);
            overflow-x: hidden; /* Hide horizontal scroll */
        }

        /* 3D Canvas - Fixed Background */
        canvas { 
            display: block; 
            position: fixed; 
            top: 0; 
            left: 0; 
            z-index: -1; 
            width: 100vw; 
            height: 100vh;
        }
        
        /* UI Overlay (Controls) - Fixed */
        #ui-container {
            position: fixed;
            top: 20px;
            right: 20px; /* Moved to right to not block text */
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            width: 220px;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h2.ui-title { margin: 0 0 15px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #888; font-weight: 600; }

        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 20px; }
        
        button {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.05);
            color: #ccc;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
            font-family: var(--font-main);
            text-transform: uppercase;
        }

        button:hover { background: rgba(255,255,255,0.15); color: white; }
        button.active { background: #fff; color: #000; font-weight: 700; border-color: #fff; }

        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 1px;}
        
        input[type="color"] {
            width: 100%; height: 30px; border: none; background: none; cursor: pointer;
        }

        /* --- Parallax Content Layout (Newtype Style) --- */
        main {
            position: relative;
            z-index: 10;
            width: 100%;
        }

        section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 10vw;
            box-sizing: border-box;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .hero-section {
            align-items: flex-start;
            padding-top: 20vh;
        }

        h1 {
            font-size: clamp(3rem, 8vw, 10rem);
            line-height: 0.9;
            font-weight: 800;
            margin: 0;
            letter-spacing: -0.03em;
            background: linear-gradient(180deg, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: clamp(1rem, 2vw, 1.5rem);
            font-weight: 300;
            color: #aaa;
            margin-top: 2rem;
            max-width: 600px;
            line-height: 1.6;
        }

        .content-section {
            align-items: flex-start;
            background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.8) 100%);
        }

        .grid-layout {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 4rem;
            width: 100%;
            margin-top: 4rem;
        }

        .sticky-label {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #666;
            font-weight: 600;
        }

        .text-block p {
            font-size: clamp(1.2rem, 3vw, 2.5rem);
            font-weight: 400;
            line-height: 1.4;
            margin: 0 0 2rem 0;
            color: #eee;
        }
        
        .text-block span {
            color: #666;
        }

        .footer-section {
            min-height: 50vh;
            justify-content: flex-end;
            padding-bottom: 4rem;
        }

        .footer-link {
            font-size: 14px;
            color: #666;
            text-decoration: none;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }

        #loading {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 2000;
        }

        .input_video { display: none; }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #050505; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        @media (max-width: 768px) {
            .grid-layout { grid-template-columns: 1fr; gap: 2rem; }
            #ui-container { width: calc(100% - 40px); top: auto; bottom: 20px; left: 20px; right: 20px; }
        }
    </style>
</head>
<body>

    <!-- Loading -->
    <div id="loading">System Initializing...</div>

    <!-- UI Panel -->
    <div id="ui-container">
        <h2 class="ui-title">Visual Template</h2>
        <div class="btn-group">
            <button onclick="setShape('heart')" id="btn-heart">Heart</button>
            <button onclick="setShape('flower')" id="btn-flower">Flower</button>
            <button onclick="setShape('saturn')" id="btn-saturn" class="active">Saturn</button>
            <button onclick="setShape('fireworks')" id="btn-fireworks">Galaxy</button>
        </div>

        <div class="control-group">
            <label>Accent Color</label>
            <input type="color" id="colorPicker" value="#00ffff">
        </div>
        
        <div class="control-group">
            <label style="color: #555; font-size: 10px; line-height: 1.4;">
                Interactive Mode Active<br>
                Gestures: Open Hand (Expand) / Fist (Contract)
            </label>
        </div>
    </div>

    <!-- Parallax Content Overlay -->
    <main>
        <!-- Section 1: Hero -->
        <section class="hero-section">
            <h1>NEW TYPE<br>OF DESIGN.</h1>
            <div class="subtitle">
                We construct digital realities through code and motion.<br>
                Experience the intersection of technology and aesthetics.
            </div>
        </section>

        <!-- Section 2: About / Philosophy -->
        <section class="content-section">
            <div class="grid-layout">
                <div class="sticky-label">01. PHILOSOPHY</div>
                <div class="text-block">
                    <p>Design is not just what it looks like and feels like. <span>Design is how it works. We believe in stripping away the unnecessary to reveal the essence of the digital experience.</span></p>
                    <p>Through real-time interaction, we bridge the gap between user intent and visual feedback.</p>
                </div>
            </div>
        </section>

        <!-- Section 3: Capabilities -->
        <section class="content-section">
            <div class="grid-layout">
                <div class="sticky-label">02. INTERACTION</div>
                <div class="text-block">
                    <p>Use your hands to control the universe behind this text. <span>Our systems are built to react, adapt, and evolve with human input.</span></p>
                </div>
            </div>
        </section>

        <!-- Section 4: Footer -->
        <section class="footer-section">
            <div class="grid-layout">
                <div class="sticky-label">CONTACT</div>
                <div class="text-block">
                    <p style="font-size: 1.5rem;">hello@newtype.design</p>
                    <a href="#" class="footer-link">Instagram</a> &nbsp;
                    <a href="#" class="footer-link">Twitter</a>
                    <br><br>
                    <div style="font-size: 12px; color: #444;">Â© 2025 NEWTYPE DESIGN. All Rights Reserved.</div>
                </div>
            </div>
        </section>
    </main>

    <!-- Hidden Video -->
    <video class="input_video"></video>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. Three.js Setup ---
        const scene = new THREE.Scene();
        // Darker fog for depth
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Disable auto clear to potentially handle trails, but standard here
        document.body.appendChild(renderer.domElement);

        // --- 2. Particle System Logic ---
        const PARTICLE_COUNT = 18000; // Increased count for denser look
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // Initialize random
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 150;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        const material = new THREE.PointsMaterial({
            size: 0.15,
            color: 0x00ffff,
            map: sprite,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Logic (Copied & Optimized) ---
        function getPointOnHeart(t) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            return { x: x, y: y };
        }

        function generateShape(type) {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    const p = getPointOnHeart(t);
                    const r = Math.random() * 2;
                    const phi = Math.random() * Math.PI * 2;
                    x = p.x + r * Math.cos(phi);
                    y = p.y + r * Math.sin(phi);
                    z = r * Math.sin(phi) * 4;
                } else if (type === 'flower') {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = 15 + 5 * Math.sin(phi * 6);
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);
                } else if (type === 'saturn') {
                    const r = Math.random();
                    if (r > 0.4) {
                        const radius = 9;
                        const phi = Math.acos( -1 + ( 2 * Math.random() ) );
                        const theta = Math.sqrt( PARTICLE_COUNT * Math.PI ) * phi;
                        x = radius * Math.cos( theta ) * Math.sin( phi );
                        y = radius * Math.sin( theta ) * Math.sin( phi );
                        z = radius * Math.cos( phi );
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 14 + Math.random() * 8;
                        x = Math.cos(angle) * radius;
                        z = Math.sin(angle) * radius;
                        y = (Math.random() - 0.5) * 0.2;
                        
                        const tilt = 0.5;
                        const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
                        y = ty; z = tz;
                    }
                } else if (type === 'fireworks') {
                    const r = Math.pow(Math.random(), 1/3) * 25;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                arr[i3] = x; arr[i3 + 1] = y; arr[i3 + 2] = z;
            }
            return arr;
        }

        let currentShape = 'saturn';
        let handOpenness = 0.5;
        let smoothedOpenness = 0.5;

        function updateTargetPositions() {
            const newPos = generateShape(currentShape);
            targetPositions.set(newPos);
        }
        updateTargetPositions();

        window.setShape = (shape) => {
            currentShape = shape;
            updateTargetPositions();
            document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${shape}`).classList.add('active');
        };

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });

        // --- 3. Parallax & Interaction Loop ---
        
        let scrollY = 0;
        window.addEventListener('scroll', () => {
            scrollY = window.scrollY;
        });

        function animate() {
            requestAnimationFrame(animate);

            // 1. Hand Interaction
            smoothedOpenness += (handOpenness - smoothedOpenness) * 0.1;
            const handScale = 0.3 + (smoothedOpenness * 1.5);
            
            // 2. Parallax Calculation
            // Rotate particles based on scroll
            const scrollRotation = scrollY * 0.0005;
            // Move camera down slightly as we scroll down
            const scrollYOffset = scrollY * 0.01;

            // Update Particles
            const positionsAttribute = geometry.attributes.position;
            const array = positionsAttribute.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                array[i3] += (targetPositions[i3] - array[i3]) * 0.04;
                array[i3 + 1] += (targetPositions[i3 + 1] - array[i3 + 1]) * 0.04;
                array[i3 + 2] += (targetPositions[i3 + 2] - array[i3 + 2]) * 0.04;
            }
            positionsAttribute.needsUpdate = true;

            // Apply Hand Scale
            particles.scale.setScalar(handScale);
            
            // Apply Scroll/Parallax Rotation
            // Base rotation + Scroll influence
            particles.rotation.y = (Date.now() * 0.0002) + scrollRotation;
            particles.rotation.z = (Date.now() * 0.0001);

            // Optional: Move camera based on scroll for more depth
            // camera.position.y = -scrollYOffset; 

            renderer.render(scene, camera);
        }

        animate();

        // --- 4. Hand Tracking ---
        const videoElement = document.getElementsByClassName('input_video')[0];

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let totalOpenness = 0;
                results.multiHandLandmarks.forEach((landmarks) => {
                    const wrist = landmarks[0];
                    const tips = [4, 8, 12, 16, 20];
                    let avgDist = 0;
                    tips.forEach(tipIndex => {
                        const tip = landmarks[tipIndex];
                        avgDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    });
                    avgDist /= 5;
                    let openness = (avgDist - 0.1) / 0.25;
                    openness = Math.max(0, Math.min(1, openness));
                    totalOpenness += openness;
                });
                handOpenness = totalOpenness / results.multiHandLandmarks.length;
            } else {
                handOpenness = 0.5; 
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 640, height: 480
        });
        cameraUtils.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
