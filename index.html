<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universe → Saturn Magic</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; }
        #info { position:absolute; top:20px; left:20px; z-index:100; background:rgba(0,0,0,0.6); padding:14px 28px; border-radius:30px; backdrop-filter:blur(10px); color:#fff; font-size:15px; }
    </style>
</head>
<body>
<div id="info">손 인터랙션 테스트</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three …
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>

<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 32;
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(innerWidth, innerHeight); renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0x404040));

    const COUNT = 3200;
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(COUNT * 3);
    const base = new Float32Array(COUNT * 3);
    const target = new Float32Array(COUNT * 3);
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // 은은한 파티클 텍스처
    const canvas = document.createElement('canvas'); canvas.width = canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0,16,16,16);
    grad.addColorStop(0,'rgba(255,255,255,1)');
    grad.addColorStop(0.4,'rgba(255,255,255,0.4)');
    grad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
    const tex = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.6, map: tex, transparent: true, opacity: 0.9,
        depthWrite: false, blending: THREE.AdditiveBlending, color: 0xffffff
    });
    const particles = new THREE.Points(geom, mat);
    scene.add(particles);

    // 새턴 기준 위치
    for(let i = 0; i < COUNT; i++){
        if(Math.random() > 0.3){
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            const r = 6;
            base[i*3]   = r * Math.sin(phi) * Math.cos(theta);
            base[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            base[i*3+2] = r * Math.cos(phi);
        } else {
            const ang = Math.random() * Math.PI * 2;
            const d = 9 + Math.random() * 6;
            base[i*3]   = d * Math.cos(ang);
            base[i*3+1] = (Math.random() - 0.5) * 0.8;
            base[i*3+2] = d * Math.sin(ang);
        }
    }

    let zoom = 6.0;
    function updateTarget() {
        for(let i = 0; i < COUNT * 3; i++) target[i] = base[i] * zoom;
    }
    updateTarget();

    // 두 손 인터랙션
    const video = document.createElement('video');
    video.style.display = 'none';
    document.body.appendChild(video);
    let dist = 0, detected = false;

    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}`});
    hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7});
    hands.onResults(r => {
        detected = r.multiHandLandmarks && r.multiHandLandmarks.length === 2;
        if(detected){
            const a = r.multiHandLandmarks[0][8];
            const b = r.multiHandLandmarks[1][8];
            dist = Math.hypot(a.x - b.x, a.y - b.y);
        }
    });
    new Camera(video, {onFrame: async () => await hands.send({image: video}), width: 640, height: 480}).start();

    // 애니메이션
    let t = 0;
    function animate(){
        requestAnimationFrame(animate); t += 0.01;

        const targetZoom = detected ? Math.max(0.9, Math.min(7, (dist - 0.05) * 13)) : 6.0;
        zoom += (targetZoom - zoom) * 0.08;
        updateTarget();

        const pos = geom.attributes.position.array;
        for(let i = 0; i < COUNT * 3; i++) {
            pos[i] += (target[i] - pos[i]) * 0.08;
        }
        geom.attributes.position.needsUpdate = true;

        particles.rotation.y += 0.003;
        particles.rotation.x += 0.0008;
        mat.size = 0.6 + Math.sin(t * 4) * 0.06;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
</script>
</body>
</html>
