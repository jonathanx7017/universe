<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saturn Zoom – Original Feel</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; }
        #info { position:absolute; top:20px; left:20px; z-index:100; background:rgba(0,0,0,0.6); padding:14px 28px; border-radius:30px; backdrop-filter:blur(10px); color:#fff; font-size:15px; }
        #menu { position:absolute; bottom:40px; left:50%; transform:translateX(-50%); z-index:100; background:rgba(15,15,25,0.9); padding:16px 36px; border-radius:50px; backdrop-filter:blur(15px); border:1px solid rgba(100,160,255,0.4); box-shadow:0 10px 40px rgba(0,0,0,0.7); display:flex; gap:22px; }
        .btn { padding:13px 30px; background:rgba(40,40,70,0.7); color:#ddd; border:1px solid rgba(120,180,255,0.5); border-radius:30px; cursor:pointer; font-weight:600; font-size:15px; transition:all .3s; min-width:100px; text-align:center; }
        .btn:hover { background:rgba(80,140,255,0.4); color:white; }
        .btn.active { background:linear-gradient(135deg,#5af,#28f); color:white; box-shadow:0 0 25px rgba(100,180,255,0.8); border:none; }
    </style>
</head>
<body>
<div id="info">손 오므리기 → 새턴 선명 • 벌리기 → 우주처럼 퍼짐</div>
<div id="menu">
    <div class="btn active">Saturn</div>
    <div class="btn">Sphere</div>
    <div class="btn">Heart</div>
    <div class="btn">Flower</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>

<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 32;
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(innerWidth, innerHeight); renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0x404040));

    const COUNT = 3200;
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT*3);
    const base = new Float32Array(COUNT*3);     // 새턴 기준 위치
    const target = new Float32Array(COUNT*3);   // 현재 확대/축소된 위치
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));

    // ★ 완전 원래 그 은은한 파티클 텍스처 ★
    const canvas = document.createElement('canvas'); canvas.width=canvas.height=32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0,16,16,16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.4, 'rgba(255,255,255,0.4)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
    const tex = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.6,            // 원래 크기
        map: tex,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        color: 0xffffff
    });
    const particles = new THREE.Points(geom, mat); scene.add(particles);

    // 새턴 기준 위치 생성
    for(let i=0; i<COUNT; i++){
        if(Math.random() > 0.3){
            const u=Math.random(), v=Math.random();
            const theta=2*Math.PI*u, phi=Math.acos(2*v-1);
            const r=6;
            base[i*3]   = r*Math.sin(phi)*Math.cos(theta);
            base[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
            base[i*3+2] = r*Math.cos(phi);
        } else {
            const ang=Math.random()*Math.PI*2;
            const d=9+Math.random()*6;
            base[i*3]   = d*Math.cos(ang);
            base[i*3+1] = (Math.random()-0.5)*0.8;
            base[i*3+2] = d*Math.sin(ang);
        }
    }

    let zoom = 6.0;  // 시작은 6배 퍼진 상태
    function updateTarget(){ for(let i=0;i<COUNT*3;i++) target[i]=base[i]*zoom; }
    updateTarget();

    // 손 인식
    const video = document.createElement('video'); video.style.display='none'; document.body.appendChild(video);
    let dist=0, detected=false;
    const hands = new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}`});
    hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});
      hands.onResults(r => {
    if (r.multiHandLandmarks && r.multiHandLandmarks.length >= 1) {
        const lm = r.multiHandLandmarks[0];  // 첫 번째 손만 사용

        // 손바닥 중심: 손목(0) + 중지 MCP(9) 평균
        const palmX = (lm[0].x + lm[9].x) / 2;
        const palmY = (lm[0].y + lm[9].y) / 2;

        // 엄지 끝 (4번)
        const thumbX = lm[4].x;
        const thumbY = lm[4].y;

        // 손바닥 중심 ↔ 엄지 끝 거리
        let rawDist = Math.hypot(thumbX - palmX, thumbY - palmY);

        // 한 손이라 값이 작아서 보정 + 부드럽게 만들기
        dist = rawDist * 18 + 0.15;  // 이 값이 딱 좋음 (테스트 완료)
        detected = true;
    } else {
        detected = false;
    }
});
    new Camera(video,{onFrame:async()=>await hands.send({image:video}),width:640,height:480}).start();

    // 애니메이션
    let t=0;
    function animate(){
        requestAnimationFrame(animate); t+=0.01;

        // 손으로 줌 제어
        const targetZoom = detected ? Math.max(0.9, Math.min(7, dist * 11)) : 6.0;
        zoom += (targetZoom - zoom)*0.08;
        updateTarget();

        // 부드럽게 따라가기
        const p = geom.attributes.position.array;
        for(let i=0;i<COUNT*3;i++) p[i] += (target[i]-p[i])*0.08;
        geom.attributes.position.needsUpdate = true;

        particles.rotation.y += 0.003;
        particles.rotation.x += 0.0008;

        // 아주 은은한 반짝임만
        mat.size = 0.6 + Math.sin(t*4)*0.06;

        renderer.render(scene,camera);
    }
    animate();

    window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});
</script>
</body>
</html>
